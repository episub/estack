// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots
package loader

import (
	"{{.Config.PackageName}}/models"
	"{{.Config.PackageName}}/gnorm"
	"{{.Config.PackageName}}/gnorm/dbl"
	"{{.ModelPackage}}"
	"github.com/episub/estack/validate"
	"github.com/codemodus/kace"
	opentracing "github.com/opentracing/opentracing-go"
)

// {{.ModelName}}FetchRequest A request for a {{camel .ModelName}} object, to be batched
type {{.ModelName}}FetchRequest struct {
	{{.ModelName}}ID {{.PrimaryKeyType}}
	Reply    chan {{.ModelName}}FetchReply
}

// {{.ModelName}}FetchReply A reply with the requested object or an error
type {{.ModelName}}FetchReply struct {
	{{.ModelName}} dbl.{{.ModelName}}Full
	Error  error
}

var {{camel .ModelName}}Initialised bool
var {{camel .ModelName}}FRs []{{.ModelName}}FetchRequest
var {{camel .ModelName}}MX sync.Mutex

// Get{{.ModelName}} Returns {{.ModelPackageShort}}.{{.ModelName}} with given ID
{{- $idName := snake .ModelName}}
func (l *PostgresLoader) Get{{.ModelName}}(ctx context.Context, id {{.PrimaryKeyType}}) (o {{.ModelPackageShort}}.{{.ModelName}}, err error) {
	return l.get{{.ModelName}}(ctx, id, l.pool)
}

// get{{.ModelName}} Returns {{.ModelPackageShort}}.{{.ModelName}} with given ID, using provided DB connection
func (l *PostgresLoader) get{{.ModelName}}(ctx context.Context, id {{.PrimaryKeyType}}, db gnorm.DB) (o {{.ModelPackageShort}}.{{.ModelName}}, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "Get{{.ModelName}}")
	defer span.Finish()

	r, err := l.batchedGet{{.PmName}}(id, l.pool)

	if err != nil {
		err = sanitiseError(err)
		return
	}

	o = hydrateModel{{.ModelName}}(ctx, r)

	return
}

func (l *PostgresLoader) batchedGet{{.ModelName}}(id {{.PrimaryKeyType}}, db gnorm.DB) (o dbl.{{.PmName}}Full, err error) {
	{{camel .ModelName}}MX.Lock()
	if !{{camel .ModelName}}Initialised {
		err = fmt.Errorf("batchedGet{{.ModelName}} not initialised.  Add 'go loader.run{{.ModelName}}Batcher()' to init")
	}
	{{camel .ModelName}}MX.Unlock()
	if err != nil {
		return
	}

	rchan := make(chan {{.ModelName}}FetchReply)
	r := {{.ModelName}}FetchRequest{
		{{.ModelName}}ID: id,
		Reply:    rchan,
	}

	{{camel .ModelName}}MX.Lock()
	{{camel .ModelName}}FRs = append({{camel .ModelName}}FRs, r)
	{{camel .ModelName}}MX.Unlock()

	reply := <-rchan

	return reply.{{.ModelName}}, reply.Error
}

func (l *PostgresLoader) run{{.ModelName}}Batcher() {
	{{camel .ModelName}}MX.Lock()
	{{camel .ModelName}}Initialised = true
	{{camel .ModelName}}MX.Unlock()
	for {
		time.Sleep(time.Millisecond * 20)

		{{camel .ModelName}}MX.Lock()
		if len({{camel .ModelName}}FRs) > 0 {
			var {{camel .ModelName}}s []dbl.{{.PmName}}Full
			var err error
			var ids []{{.PrimaryKeyType}}

			for _, r := range {{camel .ModelName}}FRs {
				ids = append(ids, r.{{.ModelName}}ID)
			}

			log.Printf("Batched {{camel .ModelName}} size: %d", len({{camel .ModelName}}FRs))
			{{camel .ModelName}}s, err = dbl.GetMulti{{.PmName}}Full(context.Background(), l.pool, ids)

		OUTER:
			for _, r := range {{camel .ModelName}}FRs {
				for _, c := range {{camel .ModelName}}s {
					if c.{{.ModelName}}ID == r.{{.ModelName}}ID {
						r.Reply <- {{.ModelName}}FetchReply{ {{.ModelName}}: c, Error: nil}
						continue OUTER
					}
				}

				err2 := err

				if err2 == nil {
					err2 = fmt.Errorf("Not found")
				}
				r.Reply <- {{.ModelName}}FetchReply{Error: err2}
			}

			{{camel .ModelName}}FRs = []{{.ModelName}}FetchRequest{}
		}

		{{camel .ModelName}}MX.Unlock()
	}
}

// GetAll{{.ModelName}} Returns an array of all {{.ModelName}} entries, using the provided filter
func (l *PostgresLoader) GetAll{{.ModelName}}(ctx context.Context, filter models.Filter) (all []{{.ModelPackageShort}}.{{.ModelName}}, pi models.PageInfo, count int, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "GetAll{{.ModelName}}")
	defer span.Finish()

	descending := filter.Order.Descending
	// If filter.Before, we reverse the order of the results now:
	if filter.Before {
		filter.Order.Descending = !descending
	}

	r, hasMore, count, err := dbl.QueryPaginated{{.PmName}}Full(ctx, l.pool, filter.Cursor, filter.Where, filter.Order, filter.Count)

	if err != nil {
		return
	}

	// We may need to reverse the order back again if we swapped it:
	if descending != filter.Order.Descending {
		// Restore the order
		for i := len(r)/2 - 1; i >= 0; i-- {
			opp := len(r) - 1 - i
			r[i], r[opp] = r[opp], r[i]
		}
	}

	if filter.Before {
		pi.HasPreviousPage = hasMore
		if filter.Cursor != nil {
			pi.HasNextPage = true
		}
	} else {
		pi.HasNextPage = hasMore
		if filter.Cursor != nil {
			pi.HasPreviousPage = true
		}
	}


	all = make([]{{.ModelPackageShort}}.{{.ModelName}}, len(r))
	for i, b := range r {
		all[i] = hydrateModel{{.ModelName}}(ctx, b)
	}

	return
}

{{if .Create}}
// Update{{.ModelName}} Updates {{.ModelName}} based on provided changes
func (l *PostgresLoader) Update{{.ModelName}}(ctx context.Context, id {{.PrimaryKeyType}}, u map[string]interface{}) error {
	tx, err := l.pool.Begin()

	if err != nil {
		return err
	}

	err = l.update{{.ModelName}}(ctx, tx, id, u)
	if rollbackErr(err, tx) != nil {
		return err
	}

	return tx.Commit()
}

// update{{.ModelName}} Updates {{.ModelName}} based on provided changes using provided db connection
func (l *PostgresLoader) update{{.ModelName}}(ctx context.Context, db gnorm.DB, id {{.PrimaryKeyType}}, u map[string]interface{}) error {
	{{camel .ModelName}}, err := dbl.Get{{.PmName}}Full(ctx, l.pool, id)

	if err != nil {
		return err
	}

	// Helps us keep track of which field has any errors
	pathCtx := addPathToContext(ctx, kace.Snake("{{.ModelName}}"))

	// By iterating over the map entries, we can ensure we only modify those values that are set:
	for k, v := range u {
		err = l.update{{.ModelName}}Field(pathCtx, false, db, &{{camel .ModelName}}, k, v)

		if err != nil {
			return fmt.Errorf("%s: %s", k, err)
		}
	}

	l.validate{{.PmName}}(pathCtx, {{camel .ModelName}})

	if validate.HasErrors(ctx) {
		log.Print("Found validation errors in update{{.ModelName}}")

		// Only return an error if this is top path:
		if isTopPath(ctx) {
			log.Printf("Validation errors: %s", validate.ErrorsString(ctx))
			return fmt.Errorf("Unresolved validation errors, cannot complete action")
		}
		return nil
	}

	_, err = dbl.Upsert{{.PmName}}Full(ctx, db, {{camel .ModelName}})

	return sanitiseError(err)
}

// create{{.PmName}} Creates {{.PmName}} from given input
func (l *PostgresLoader) create{{.PmName}}(ctx context.Context, db DB, i map[string]interface{}) (o dbl.{{.PmName}}Full, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "create{{.PmName}}")
	defer span.Finish()

	// Helps us keep track of which field has any errors
	pathCtx := addPathToContext(ctx, kace.Snake("{{.ModelName}}"))

	for k, v := range i {
		err = l.update{{.ModelName}}Field(pathCtx, true, db, &o, k, v)

		if err != nil {
			err = fmt.Errorf("%s: %s", k, err)
			return
		}
	}

	l.validate{{.PmName}}(pathCtx, o)

	if validate.HasErrors(ctx) {
		log.Print("Found validation errors in create{{.PmName}}")
		if isTopPath(ctx) {
			log.Printf("Validation errors: %s", validate.ErrorsString(ctx))
			return o, fmt.Errorf("Unresolved validation errors, cannot complete action")
		}
		return o, nil
	}

	o, err = dbl.Upsert{{.PmName}}Full(ctx, db, o)

	return o, sanitiseError(err)
}
{{end}}
