// Code generated by gnorm, DO NOT EDIT!
{{$package := index .Params "packageName"}}
{{with .Table}}
package dbl

import (
	"strings"

	"{{$package}}/gnorm"
	"cloud.google.com/go/civil"
	"github.com/episub/pqt"
	opentracing "github.com/opentracing/opentracing-go"
	"github.com/gofrs/uuid"
)

{{$table := .DBName -}}
{{$schema := .Schema.DBName -}}
// {{.Name}} represents a row from '{{ $table }}'.
type {{.Name}} struct {
{{- range .Columns }}
	{{ .Name }} {{ .Type }}  // {{ .DBName }}
{{- end }}
}

// Field values for every column in {{.Name}}.
var (
{{- range .Columns }}
	{{pascal $table}}{{.Name}}Col gnorm.{{ title (replace (replace (replace .Type "." "" 1) "[]" "" 1) "*" "" 1)}}Field = "{{ .DBName }}"
{{- end -}}
)

{{if hasPrefix .DBName "view_"}}
{{else}}
// Upsert{{.Name}} Creates or updates record based on input
func Upsert{{.Name}}(ctx context.Context, db gnorm.DB, o {{.Name}}) ({{.Name}}, error) {
	span, _ := opentracing.StartSpanFromContext(ctx, "Upsert{{.Name}}")
	defer span.Finish()

	var err error
	if err = prepare{{.Name}}Create(ctx, &o); err != nil {
		return o, err
	}
	

	// sql query
	const sqlstr = `INSERT INTO {{$schema}}.{{$table}} (` +
		`{{ join .Columns.DBNames ", " }}` +
		`) VALUES (` +
		{{- $vals := numbers 1 (len .Columns) }}
		`${{ join $vals ", $" }}` +
		`) ON CONFLICT ({{ join .PrimaryKeys.DBNames ", " }}) DO UPDATE SET (` +
		`{{ join .Columns.DBNames ", " }}` +
		`) = (` +
		`EXCLUDED.{{ join .Columns.DBNames ", EXCLUDED." }}` +
		`)`

	// run query
	_, err = db.Exec(sqlstr, o.{{join .Columns.Names ", o."}})
	if err != nil {
		return o, err
	}

	return o,nil
}

// Insert{{.Name}} Creates a record, and overrides any provided uuid primary key and created values
func Insert{{.Name}}(ctx context.Context, db gnorm.DB, o {{.Name}}) ({{.Name}}, error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "Insert{{.Name}}")
	defer span.Finish()

	var err error
	{{- range $index, $element := .PrimaryKeys}}
	{{if eq $element.DBType "uuid"}}
	// Set Primary Key empty
	o.{{$element.Name}} = ""
	{{- end -}}
	{{end}}
	{{- range $index, $element := .Columns}}
	{{- if eq $element.Name "Created"}}
	o.Created = time.Time{}
	{{- end -}}
	{{- if eq $element.Name "Effective"}}
	o.Effective = time.Time{}
	{{- end -}}
	{{- if eq $element.Name "CreatedBy"}}
	o.CreatedBy = ""
	{{- end -}}
	{{- if eq $element.Name "UpdatedBy"}}
	o.UpdatedBy = ""
	{{- end -}}
	{{end}}

	if err = prepare{{.Name}}Create(ctx, &o); err != nil {
		return o, err
	}
	
	// sql query
	const sqlstr = `INSERT INTO {{$schema}}.{{$table}} (` +
		`{{ join .Columns.DBNames ", " }}` +
		`) VALUES (` +
		{{- $vals := numbers 1 (len .Columns) }}
		`${{ join $vals ", $" }}` +
		`)`

	// run query
	_, err = db.Exec(sqlstr, o.{{join .Columns.Names ", o."}})
	if err != nil {
		return o, err
	}

	return o,nil
}

// prepare{{.Name}}Create Prepares some fields for a new {{.Name}} if they haven't been provided already.  For example, primary key UUID values, created, etc
func prepare{{.Name}}Create(ctx context.Context, o *{{.Name}}) error {
	span, ctx := opentracing.StartSpanFromContext(ctx, "prepare{{.Name}}")
	defer span.Finish()

	if o == nil {
		return nil
	}

	{{- range $index, $element := .PrimaryKeys}}
	{{if eq $element.DBType "uuid"}}
	// Set Primary Key UUID if not set:
	if len(o.{{$element.Name}}) == 0 {
		id, err := uuid.NewV4()
		if err != nil {
			return err
		}

		o.{{$element.Name}} = id.String()
	}
	{{end}}
	{{end}}

	{{- range $index, $element := .Columns}}
	{{if eq $element.Name "Created"}}
	// Set created time if not set
	if o.Created.IsZero() {
		o.Created = time.Now()
	}
	{{end}}
	{{if eq $element.Name "Updated"}}
	// Set updated to now
	o.Updated = time.Now()
	{{end}}
	{{if eq $element.Name "Effective"}}
	// Set effective time if not set
	if o.Effective.IsZero() {
		o.Effective = time.Now()
	}
	{{end}}
	{{if eq $element.Name "CreatedBy"}}
	// Set CreatedBy if not already set
	if len(o.CreatedBy) == 0 {
		createdBy, ok := ctx.Value("created_by").(string)

		if !ok {
			return fmt.Errorf("Created by not set, and no 'created_by' value found in context")
		}

		// Check that this is actually a UUID:
		_, err := uuid.FromString(createdBy)

		if err != nil {
			return fmt.Errorf("Invalid 'created_by' value found in context")
		}

		o.CreatedBy = createdBy
	}
	{{end}}
	{{if eq $element.Name "UpdatedBy"}}
	// Set UpdatedBy to current user
	updatedBy, ok := ctx.Value("created_by").(string)

	if !ok {
		return fmt.Errorf("Updated by by not set, and no 'created_by' value found in context")
	}

	// Check that this is actually a UUID:
	_, err := uuid.FromString(updatedBy)

	if err != nil {
		return fmt.Errorf("Invalid 'created_by' value found in context")
	}

	o.UpdatedBy = updatedBy
	{{end}}
	{{if eq $element.DBName (printf "short_%s_id" $table)}}
	// If no short client ID is given, we select the first 10 characters of the uuid id
	if len(o.ShortClientID) == 0 {
		o.{{.Name}} = strings.Replace(o.ClientID, "-", "", -1)[:10]
	}
	{{end}}
	{{end}}

	return nil
}
{{end}}

// Query{{.Name}} retrieves rows from '{{ $table }}' as a slice of Row.
func Query{{.Name}}(ctx context.Context, db gnorm.DB, whereList []gnorm.WhereClause, order gnorm.Order) ([]{{.Name}}, error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "Query{{.Name}}")
	defer span.Finish()

	var sqlstr = `SELECT 
		{{ join .Columns.DBNames ", " }}
		FROM {{$schema}}.{{ $table }}`

	var vals []{{.Name}}
	var whereValues []interface{}

	if len(whereList) > 0 {
		sqlstr += ` WHERE (`
		var whereStrings []string

		idx := 1

		for _, where := range whereList {
			whereStrings = append(whereStrings, where.String(&idx))
			whereValues = append(whereValues, where.Values()...)
		}

		whereString := strings.Join(whereStrings, " AND ")

		sqlstr += whereString + ") "
	}

	// Order of results:
	sqlstr += " ORDER BY " + order.String()

	span.LogFields(
		log.String("query", sqlstr),
	)

	q, err := db.Query(sqlstr, whereValues...)
	if err != nil {
		return nil, err
	}
	for q.Next() {
		r := {{.Name}}{}

		err = q.Scan(
			{{- $lastCol := dec (len .Columns)  }}
			{{- range $x, $c :=  .Columns -}}
				&r.{{$c.Name}}{{ if ne $x $lastCol}}, {{end -}}
			{{end -}}
		)			
		if err != nil {
			return nil, err
		}

		vals = append(vals, r)
	}
	return vals, nil
}

// CustomQuery{{.Name}} Retrieves {{.Name}} rows using provided sql statement.  Leave a %s entry in the query to fill each of the field names and table name.  E.g., "SELECT %s FROM %s"
func CustomQuery{{.Name}}(ctx context.Context, db gnorm.DB, query string, args ...interface{}) ([]{{.Name}}, error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "Query{{.Name}}")
	defer span.Finish()

	var fields = `{{ join .Columns.DBNames ", " }}`
	var table = `{{$schema}}.{{ $table }}`
	var sqlstr = fmt.Sprintf(query, fields, table)
	var vals []{{.Name}}

	span.LogFields(
		log.String("query", sqlstr),
	)

	q, err := db.Query(sqlstr, args...)
	if err != nil {
		return nil, err
	}
	for q.Next() {
		r := {{.Name}}{}

		err = q.Scan(
			{{- $lastCol := dec (len .Columns)  }}
			{{- range $x, $c :=  .Columns -}}
				&r.{{$c.Name}}{{ if ne $x $lastCol}}, {{end -}}
			{{end -}}
		)			
		if err != nil {
			return nil, err
		}

		vals = append(vals, r)
	}
	return vals, nil
}

{{- if eq (len .PrimaryKeys) 1}}
// Get{{.Name}}ByID fetches record from '{{ $table }}' with the provided ID
func Get{{.Name}}ByID(ctx context.Context, db gnorm.DB, {{ range $index, $element := .PrimaryKeys}}{{if $index}},{{end}}{{$element.Name}} {{$element.Type}}{{end}}) ({{.Name}}, error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "Get{{.Name}}ByID")
	defer span.Finish()

	var r {{.Name}}
	{{$element := index .PrimaryKeys 0}}

	whereID := {{pascal $table}}{{$element.Name}}Col.Equals({{$element.Name}})
	dbP, err := Query{{.Name}}(ctx, db, []gnorm.WhereClause{whereID}, gnorm.Order{})

	if err != nil {
		return r, err
	}

	if len(dbP) != 1 {
		return r, fmt.Errorf("Unexpected results fetching provider")
	}

	return dbP[0], err
}

{{end}}

{{/* We want a "Full" query for each type.  Just the single table if there's no version table, otherwise a combined Table + TableVersion thing for full/*}}
{{/* If this IS the "_version" table file, we don't generate these fields */}}
{{if hasSuffix (trimSpace .DBName) "_version"}}
{{else}}
{{$child := index .Schema.TablesByName (print .DBName "_version")}}
{{$parent := .}}
{{/* We don't currently support tables with more than one primary key in these templates */}}
{{if eq (len $parent.PrimaryKeys) 1}}
{{$parentKey := (index $parent.PrimaryKeys 0)}}


// {{$parent.Name}}Full Full response of joined parent with latest child version
type {{$parent.Name}}Full struct {
	{{.Name}}
	{{if $child -}}
	{{$child.Name}}
	{{end}}
}

{{if $child}}
const full{{$parent.Name}}Query = `SELECT
p.{{ join $parent.Columns.DBNames ", p." }},
c.{{ join $child.Columns.DBNames ", c." }}
FROM {{$schema}}.{{$parent.DBName}} as p
INNER JOIN {{$schema}}.{{$child.DBName}} as c
ON p.{{$parentKey.DBName}} = c.{{$parentKey.DBName}}_{{$parent.DBName}}
AND c.created = 
(
	SELECT Max(created)
	FROM {{$schema}}.{{$child.DBName}}
	WHERE {{$parentKey.DBName}} = {{$parentKey.DBName}}_{{$parent.DBName}}
)`
{{else}}
const full{{$parent.Name}}Query = `SELECT
p.{{ join $parent.Columns.DBNames ", p." }}
FROM {{$schema}}.{{$parent.DBName}} as p
`
{{end}}

{{if $parentKey}}
{{if $child}}
var full{{$parent.Name}}PaginatedQuery = `SELECT
p.{{ join $parent.Columns.DBNames ", p." }},
c.{{ join $child.Columns.DBNames ", c." }}
FROM {{$schema}}.{{$parent.DBName}} as p
INNER JOIN {{$schema}}.{{$child.DBName}} as c
ON p.{{$parentKey.DBName}} = c.{{$parentKey.DBName}}_{{$parent.DBName}}
AND c.created = 
(
	SELECT Max(created)
	FROM {{$schema}}.{{$child.DBName}}
	WHERE {{$parentKey.DBName}} = {{$parentKey.DBName}}_{{$parent.DBName}}
)`
{{else}}
var full{{$parent.Name}}PaginatedQuery = `SELECT
p.{{ join $parent.Columns.DBNames ", p." }}
FROM {{$schema}}.{{$parent.DBName}} as p
`
{{end}}
// Upsert{{$parent.Name}}Full Upserts a full record, updating the parent table and, if a version child exists, inserting (not updating) a new record there
func Upsert{{$parent.Name}}Full(ctx context.Context, db gnorm.DB, i {{$parent.Name}}Full) ({{$parent.Name}}Full, error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "Upsert{{$parent.Name}}Full")
	defer span.Finish()

	o, err := Upsert{{$parent.Name}}(ctx, db, i.{{$parent.Name}})

	if err != nil {
		return i, err
	}

	i.{{$parent.Name}} = o

	{{if $child}}
	// Sometimes the primary key for version won't be set, particularly when the parent object has been just created
	i.{{$parentKey.Name}}{{$parent.Name}} = i.{{$parentKey.Name}}
	ov, err := Insert{{$parent.Name}}Version(ctx, db, i.{{$parent.Name}}Version)
	
	if err != nil {
		return i, err
	}

	i.{{$parent.Name}}Version = ov
	{{else}}
	{{end}}
	return i, err
}

// QueryPaginated{{$parent.Name}}Full retrieves rows from '{{ $table }}' as a slice of Row.  If count == 0, then returns all results.  Returns true if there are more results to be had than those listed
// It will first grab a list of the relevant ID's, then fetch the full objects separately.  Done this way so that we can use custom queries that join more rows for use in sorting and filtering.
func QueryPaginated{{$parent.Name}}Full(ctx context.Context, db gnorm.DB, cursor *string, whereList []gnorm.WhereClause, order gnorm.Order, count int64) (vals []{{$parent.Name}}Full, hasMore bool, total int, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "QueryPaginated{{$parent.Name}}Full")
	defer span.Finish()

	sqlstr := full{{$parent.Name}}PaginatedQuery
	var whereValues []interface{}
	var hasWhere bool

	idx := 1
	if len(whereList) > 0 {
		hasWhere = true
		sqlstr += ` WHERE (`
		var whereStrings []string

		for _, where := range whereList {
			whereStrings = append(whereStrings, where.String(&idx))
			whereValues = append(whereValues, where.Values()...)
		}

		whereString := strings.Join(whereStrings, " AND ")

		sqlstr += whereString + ") "
	}

	// Get the total number of rows possible with our existing query, before we add the cursor related conditional
  qry := fmt.Sprintf("SELECT count(*) FROM (%s) AS xyz", sqlstr)
	span.LogFields(
		log.String("countQuery", qry),
	)
	err = db.QueryRow(qry, whereValues...).Scan(&total)

	if err != nil {
		return
	}

	if cursor != nil {
		if hasWhere {
			sqlstr += " AND"
		} else {
			sqlstr += " WHERE"
			hasWhere = true
		}

		var fields []string
		//var comparisons []string
		for _, o := range order.Fields {
			fields = append(fields, o)
		}

		lgt := ">"
		if order.Descending {
			lgt = "<"
		}

		// Create the key function that allows us to limit ourselves to only results following the cursor.  We always sort by the primary key at the end to ensure a deterministic ordering of results.  No result left behind.
		compLeft, compRight := paginateCompare(order.Fields, "{{$parentKey.DBName}}", full{{$parent.Name}}PaginatedQuery, idx)
		if len(compLeft) > 0 {
			sqlstr += fmt.Sprintf(" (%s, {{$parentKey.DBName}}) %s (%s, $%d)", compLeft, lgt, compRight, idx)
		} else {
			sqlstr += fmt.Sprintf(" ({{$parentKey.DBName}}) %s ($%d)", lgt, idx)
		}
		idx++
		whereValues = append(whereValues, *cursor)

		// Add this after the above so that it doesn't get added twice to the comparison part, where we explicitly add it
	}

	err = order.AddField("{{$parentKey.DBName}}")
	if err != nil {
		return
	}

	// Order of results:
	sqlstr += " ORDER BY " + order.String()

	if count > 0 {
		sqlstr += fmt.Sprintf(" LIMIT %d", count + 1)
	}

	qry = fmt.Sprintf("SELECT {{$parentKey.DBName}} FROM (%s) AS xyz", sqlstr)
	span.LogFields(
		log.String("query", qry),
	)
	q, err := db.Query(qry, whereValues...)
	if err != nil {
		return
	}

	// Collect the ID's together, and use them to fetch the full objects.  We do this in two stages because sometimes we will explicitly replace the auto-generated query used for this function, full{{$parent.Name}}PaginatedQuery.  This allows us to use custom queries that are tailored to allow sorting and filtering by fields that may not be available in just the parent and child (version) tables alone.
	var fetchIDs []{{$parentKey.Type}}
	for q.Next() {
		var r {{$parentKey.Type}}

		err = q.Scan(&r)
		if err != nil {
			return
		}

		fetchIDs = append(fetchIDs, r)
	}


	fetched, err := Query{{$parent.Name}}Full(ctx, db, []gnorm.WhereClause{ {{$parent.Name}}{{$parentKey.Name}}Col.In(fetchIDs)})

	// Now create vals:
	vals = make([]{{$parent.Name}}Full, len(fetchIDs))
	
	found := 0
	for i, id := range fetchIDs {
		for _, v := range fetched {
			if id == v.{{$parentKey.Name}} {
				vals[i] = v
				found++
				continue
			}
		}
	}

	if found != len(fetchIDs) {
		err = fmt.Errorf("Could not find all required records")
	}

	// If count was more than 0 and we received more results than count, there are more rows to fetch
	if (count > 0 && int64(len(fetchIDs)) > count) {
		hasMore = true
		vals = vals[:len(vals)-1]
	}

	return 
}
{{end}}

// Query{{$parent.Name}}Full retrieves rows from '{{ $table }}' as a slice of Row.
func Query{{$parent.Name}}Full(ctx context.Context, db gnorm.DB, whereList []gnorm.WhereClause) ([]{{$parent.Name}}Full, error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "Query{{$parent.Name}}Full")
	defer span.Finish()

	sqlstr := full{{$parent.Name}}Query
	var vals []{{$parent.Name}}Full
	var whereValues []interface{}

	if len(whereList) > 0 {
		sqlstr += ` WHERE (`
		var whereStrings []string

		idx := 1

		for _, where := range whereList {
			whereStrings = append(whereStrings, where.String(&idx))
			whereValues = append(whereValues, where.Values()...)
		}

		whereString := strings.Join(whereStrings, " AND ")

		sqlstr += whereString + ") "
	}

	span.LogFields(
		log.String("query", sqlstr),
	)

	q, err := db.Query(sqlstr, whereValues...)
	if err != nil {
		return nil, err
	}
	for q.Next() {
		r := {{$parent.Name}}Full{}

		err = q.Scan(
			{{- range $x, $c :=  $parent.Columns -}}
				&r.{{$c.Name}},
			{{- end -}}
			{{- if $child -}}
			{{- $lastCol := dec (len $child.Columns)  }}
			{{- range $x, $c :=  $child.Columns -}}
				&r.{{$c.Name}}{{ if ne $x $lastCol}}, {{end -}}
			{{- end -}}
			{{- end -}}
		)			
		if err != nil {
			return nil, err
		}

		vals = append(vals, r)
	}
	return vals, nil
}

// Get{{$parent.Name}}Full Returns the single row corresponding to this ID
func Get{{$parent.Name}}Full(ctx context.Context, db gnorm.DB, i {{$parentKey.Type}}) (o {{$parent.Name}}Full, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "Get{{$parent.Name}}Full")
	defer span.Finish()

	r, err := Query{{$parent.Name}}Full(ctx, db, []gnorm.WhereClause{ {{.Name}}{{$parentKey.Name}}Col.In([]{{$parentKey.Type}}{i})})

	if err != nil {
		return 
	}

	if len(r) != 1 {
		err = fmt.Errorf("Expected 1 row, but had %d", len(r))
		return
	}

	o = r[0]
	return
}

// GetMulti{{$parent.Name}}Full Returns all the records corresponding to provided IDs
func GetMulti{{$parent.Name}}Full(ctx context.Context, db gnorm.DB, ids []{{$parentKey.Type}}) (o []{{$parent.Name}}Full, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "GetMulti{{$parent.Name}}Full")
	defer span.Finish()

	r, err := Query{{$parent.Name}}Full(ctx, db, []gnorm.WhereClause{ {{.Name}}{{$parentKey.Name}}Col.In(ids)})

	if err != nil {
		return 
	}

	return r, nil
}

{{end}}
{{end}}

{{if hasSuffix (trimSpace .DBName) "_version"}}
{{- $parent := (index .Schema.TablesByName (trimSuffix .DBName "_version")) -}}
{{$parentKey := (index $parent.PrimaryKeys 0)}}

//// Get{{$parent.Name}}Full Returns a full response, joining the tables.  If len(ids) = 0, returns all records
//func Get{{$parent.Name}}Full (ctx context.Context, db gnorm.DB, ids []string) ([]{{$parent.Name}}Full, error) {
//	span, ctx := opentracing.StartSpanFromContext(ctx, "Get{{$parent.Name}}Full")
//	defer span.Finish()
//
//	var vals []{{$parent.Name}}Full
//
//	sqlstr := full{{$parent.Name}}Query
//	if len(ids) > 0 {
//		sqlstr += ` WHERE p.{{$parentKey.DBName}} IN ( VALUES `
//		sqlstr += "('" + strings.Join(ids, "'::{{$parentKey.DBType}}), ('") + "'::{{$parentKey.DBType}})" + `)`
//	}
//
//	q, err := db.Query(sqlstr)
//	if err != nil {
//		return vals, err
//	}
//	for q.Next() {
//		r := {{$parent.Name}}Full{}
//
//		err = q.Scan(
//			{{- range $x, $c :=  $parent.Columns -}}
//				&r.{{$c.Name}},
//			{{end -}}
//			{{- $lastCol := dec (len .Columns)  }}
//			{{- range $x, $c :=  .Columns -}}
//				&r.{{$c.Name}}{{ if ne $x $lastCol}}, {{end -}}
//			{{end -}}
//		)			
//		if err != nil {
//			return vals, err
//		}
//
//		vals = append(vals, r)
//	}
//
//	return vals, nil
//}


{{end}}
{{end}}
