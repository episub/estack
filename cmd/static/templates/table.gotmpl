// Code generated by gnorm, DO NOT EDIT!

package {{toLower .Table.Name}}

import (
	"{{.Params.RootImport}}"
	"{{.Params.RootImport}}/{{toLower .Table.Schema.Name}}/enum"
	sq "github.com/Masterminds/squirrel"
	uuid "github.com/gofrs/uuid"
	"github.com/pkg/errors"
)

// TableName is the primary table that this particular gnormed file deals with.
const TableName = "{{.Table.DBName}}"

{{$rootPkg := .Params.RootPkg -}}
{{$params := .Params -}}
{{$table := .Table.DBName -}}
{{$schema := .Table.Schema.DBName -}}
{{$hasCreatedAt := ne (len (.Table.Columns.DBNames.Except (makeSlice .Params.CreatedAtField))) (len .Table.Columns.DBNames)}}
{{$hasUpdatedAt := ne (len (.Table.Columns.DBNames.Except (makeSlice .Params.UpdatedAtField))) (len .Table.Columns.DBNames)}}
{{$colsByName := .Table.ColumnsByName }}

{{- $nonPKDBNames := .Table.Columns.DBNames.Sorted.Except .Table.PrimaryKeys.DBNames}}


// Row represents a row from '{{ $table }}'.
type Row struct {
{{- range .Table.PrimaryKeys.DBNames.Sorted }}{{ with (index $colsByName .)}}
	{{ .Name }} {{ if .IsArray }}[]{{ end }}{{ .Type }}  // {{ .DBName }} (PK){{end}}
{{- end }}
{{- range $nonPKDBNames }}{{ with (index $colsByName .) }}
	{{ .Name }} {{ if .IsArray }}[]{{ end }}{{ .Type }}  // {{ .DBName }}{{end}}
{{- end }}
}


// Field values for every column in {{.Table.Name}}.
var (
{{- range .Table.Columns.DBNames.Sorted }}{{with index $colsByName .}}
	{{- if or (hasPrefix .Type (printf "%s." $rootPkg)) (hasPrefix .Type "enum.")}}
	{{.Name}}Col {{ .Type }}Field = "{{ .DBName }}"
	{{- else}}
	{{.Name}}Col = "{{ .DBName }}"
	{{- end}}{{end}}
{{- end}}
)

// All retrieves all rows from '{{ $table }}' as a slice of Row.
func All(ctx context.Context, db {{$rootPkg}}.DB) ([]*Row, error) {
	qry := gnorm.Qry().Select(`{{ join .Table.Columns.DBNames.Sorted ", " }}`)
	qry.From(`{{$schema}}.{{$table}}`)
	sqlstr, _, err := qry.ToSql()
	if err != nil {
		return nil, err
	}

	var vals []*Row
	q, err := db.QueryContext(ctx, sqlstr)
	if err != nil {
		return nil, errors.Wrap(err, "query {{.Table.Name}}")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan({{- range .Table.Columns.DBNames.Sorted}}{{with index $colsByName .}}
		{{- if .IsArray }}pq.Array(&r.{{ .Name }}),{{- else -}}&r.{{ .Name }},{{ end }}{{end}}
{{end -}})
		if err != nil {
			return nil, errors.Wrap(err, "all {{.Table.Name}}")
		}
		vals = append(vals, &r)
	}
	return vals, nil
}

// CountQuery retrieve one row from '{{ $table }}'.
func CountQuery(ctx context.Context, db gnorm.DB, where []sq.Sqlizer) (int, error) {
	qry := gnorm.Qry().Select(`count(*) as count`)
	qry = qry.From("{{$schema}}.{{ $table }}")
	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return 0, err
	}

	count := 0
	err = db.QueryRowContext(ctx, sqlstr, args...).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "count {{.Table.Name}}")
	}
	return count, nil
}

// Query retrieves rows from '{{ $table }}' as a slice of Row.
func Query(ctx context.Context, db {{$rootPkg}}.DB, where []sq.Sqlizer) ([]*Row, error) {
	qry := gnorm.Qry().Select(`{{ join .Table.Columns.DBNames ", " }}`)
	qry = qry.From("{{$schema}}.{{ $table }}")
	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return nil, err
	}

	var vals []*Row
	q, err := db.QueryContext(ctx, sqlstr, args...)
	if err != nil {
		return nil, errors.Wrap(err, "query {{.Table.Name}}")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan({{- range .Table.Columns}}
		{{- if .IsArray }}pq.Array(&r.{{ .Name }}),{{- else -}}&r.{{ .Name }},{{ end }}
{{end -}})
		if err != nil {
			return nil, errors.Wrap(err, "query {{.Table.Name}}")
		}
		vals = append(vals, &r)
	}
	return vals, nil
}


{{/* Takes the number of values to produce and produces a list of postgres
placeholders of the form $1, $2, etc */}}
{{- define "values" -}}
	{{$nums := numbers 1 . -}}
	{{$indices := $nums.Sprintf "$%s" -}}
	{{join $indices ", " -}}
{{end}}


{{- $PKFields := join (.Table.PrimaryKeys.Names.Sorted.Sprintf "r.%s") ", "}}
{{- $PKScanFields := join (.Table.PrimaryKeys.Names.Sorted.Sprintf "&r.%s") ", "}}

{{- $numNonPKs := sub (len .Table.Columns) (len .Table.PrimaryKeys)}}


{{if .Table.HasPrimaryKey }}
// Find retrieves a row from '{{ $table }}' by its primary key(s).
func Find(ctx context.Context, db {{$rootPkg}}.DB,
{{- range .Table.PrimaryKeys.DBNames.Sorted}}
	{{- with index $colsByName .}}
	{{camel .DBName}} {{.Type}},{{end}}
{{end -}}) (*Row, error) {
	const sqlstr = `SELECT
		{{ join .Table.Columns.DBNames.Sorted ", " }}
	FROM {{$schema}}.{{ $table }} WHERE ( {{join .Table.PrimaryKeys.DBNames.Sorted ", "}} = {{template "values" (len .Table.PrimaryKeys)}} )`

	r := &Row{}
	err := db.QueryRowContext(ctx, sqlstr,
	{{- range .Table.PrimaryKeys.DBNames.Sorted}}
		{{camel .}},
	{{end -}}).Scan({{- range .Table.Columns.DBNames.Sorted}}{{with index $colsByName .}}
		{{- if .IsArray }}pq.Array(&r.{{ .Name }}),{{- else -}}&r.{{ .Name }},{{ end }}{{end}}
{{end -}})
	if err != nil {
		return nil, errors.Wrap(err, "find {{.Table.Name}}")
	}
	return r, nil
}
{{end}}


{{if .Table.HasPrimaryKey }}
// Delete deletes the Row from the database. Returns the number of items deleted.
func Delete( ctx context.Context,
	db {{$rootPkg}}.DB,
{{- range .Table.PrimaryKeys.DBNames.Sorted}}{{with index $colsByName .}}
	{{camel .DBName}} {{.Type}},{{end}}
{{end -}}
) (int64, error) {
	const sqlstr = `DELETE FROM {{$schema}}.{{ $table }} 
	WHERE
	  {{$last := dec (len .Table.PrimaryKeys)}} 
	  {{- range $x, $name := .Table.PrimaryKeys.DBNames.Sorted -}}
		{{$name}} = ${{inc $x}}{{if lt $x $last}} AND {{end}}
	  {{- end}}
	`

	res, err := db.ExecContext(ctx, sqlstr,
	{{- range .Table.PrimaryKeys.DBNames.Sorted -}}
		{{camel .}},
	{{- end -}}
	)
	if err != nil {
		return 0, errors.Wrap(err, "delete {{.Table.Name}}")
	}
	rows, err := res.RowsAffected()
	if err != nil {
		return 0, err
	}
	return rows, nil
}
{{end}}

// DeleteWhere deletes Rows from the database and returns the number of rows deleted.
func DeleteWhere(ctx context.Context, db {{$rootPkg}}.DB, where []sq.Sqlizer) (int64, error) {
	qry := gnorm.Qry().Delete("")
	qry = qry.From("{{$schema}}.{{ $table }}")
	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return 0, err
	}

	res, err := db.ExecContext(ctx, sqlstr, args...)
	if err != nil {
		return 0, errors.Wrap(err, "delete {{.Table.Name}}")
	}
	return res.RowsAffected()
}

// DeleteAll deletes all Rows from the database and returns the number of rows deleted.
func DeleteAll(ctx context.Context, db {{$rootPkg}}.DB) (int64, error) {
	const sqlstr = `DELETE FROM {{$schema}}.{{ $table }}`

	res, err := db.ExecContext(ctx, sqlstr)
	if err != nil {
		return 0, errors.Wrap(err, "deleteall {{.Table.Name}}")
	}
	return res.RowsAffected()
}
